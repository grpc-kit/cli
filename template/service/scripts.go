// Copyright © 2020 The gRPC Kit Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import "fmt"

func (t *templateService) fileDirectoryScripts() {
	t.files = append(t.files, &templateFile{
		name:  "scripts/env",
		parse: true,
		body: `
# Code generated by "grpc-kit-cli/{{ .Global.ReleaseVersion }}". DO NOT EDIT.
#
# https://grpc-kit.com/docs/spec-api/key-terms/

# 工具版本：生成该模版所使用的 cli 版本
CLI_VERSION={{ .Global.ReleaseVersion }}

# 产品代码：同一产品使用相同代码，使用单个词
PRODUCT_CODE={{ .Global.ProductCode }}

# 应用短名：同一产品使用相同代码，使用单个词
SHORT_NAME={{ .Global.ShortName }}

# 接口版本：全局接口版本
API_VERSION={{ .Template.Service.APIVersion }}

# 应用名称：用于生成文件的命名
APPNAME=${PRODUCT_CODE}-${SHORT_NAME}-${API_VERSION}

# 服务代码：用于 grpc 服务之间调用
SERVICE_CODE=${SHORT_NAME}.${API_VERSION}.${PRODUCT_CODE}
`,
	})

	t.files = append(t.files, &templateFile{
		name: "scripts/docker.sh",
		body: `
#!/bin/bash

source scripts/env

if test -z $1; then
  echo "Usage:"
  echo "\t ./scripts/docker.sh build"
  echo "\t ./scripts/docker.sh push"
fi

# 生成的容器镜像地址
IMAGE_ADDR=${IMAGE_HOST}/${NAMESPACE}/${SHORTNAME}:${IMAGE_VERSION}

function build() {
  # 如未设置父镜像，默认为scratch
  if test -z ${IMAGE_FROM}; then
    IMAGE_FROM=scratch
  fi

  cp scripts/templates/Dockerfile ./

  GOHOSTOS=$(go env GOHOSTOS)

  if test ${GOHOSTOS} = "darwin"; then
    sed -i "" "s#{{IMAGE_FROM}}#${IMAGE_FROM}#g" Dockerfile
  else
    sed -i "s#{{IMAGE_FROM}}#${IMAGE_FROM}#g" Dockerfile
  fi

  docker build -t ${IMAGE_ADDR} ./
  echo "Now you can upload image: "docker push ${IMAGE_ADDR}""
}

function push() {
  docker push ${IMAGE_ADDR}
}

function run() {
  docker run -i -t --rm \
      -v $GOPATH/pkg:/go/pkg \
      -v $(pwd):/usr/local/src \
      -w /usr/local/src \
      --network host \
      registry.cn-hangzhou.aliyuncs.com/grpc-kit/cli:${CLI_VERSION} \
      make run
}

$1
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/genproto.sh",
		parse: true,
		body: `
#!/bin/bash

source scripts/env

# 生成 *.pb.go 文件
protoc \
    -I ./ \
    -I /usr/local/include/ \
    -I "${GOPATH}"/src \
    -I "${GOPATH}"/src/github.com/grpc-ecosystem/grpc-gateway/ \
    -I "${GOPATH}"/src/github.com/googleapis/googleapis/ \
    --go_opt paths=source_relative \
    --go_out ./ \
    --go-grpc_opt paths=source_relative \
    --go-grpc_opt require_unimplemented_servers=false \
    --go-grpc_out ./ \
    ./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/*.proto

# 生成 *.pb.gw.go 与 swagger 接口文档
protoc \
    -I ./ \
    -I /usr/local/include/ \
    -I "${GOPATH}"/src \
    -I "${GOPATH}"/src/github.com/googleapis/googleapis/ \
    -I "${GOPATH}"/src/github.com/grpc-ecosystem/grpc-gateway/ \
    --grpc-gateway_opt paths=source_relative \
    --grpc-gateway_opt grpc_api_configuration=./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.gateway.yaml \
    --grpc-gateway_out ./ \
    --openapiv2_opt disable_default_errors=true \
    --openapiv2_opt disable_service_tags=true \
    --openapiv2_opt grpc_api_configuration=./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.gateway.yaml \
    --openapiv2_opt openapi_configuration=./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml \
    --openapiv2_out ./ \
    ./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.proto

# 移动生成的 microservice.swagger.json 文件
if test -f ./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.swagger.json; then
  mv ./api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.swagger.json ./public/doc/openapi-spec/
fi
`,
	})

	t.files = append(t.files, &templateFile{
		name: "scripts/precheck.sh",
		body: `
#!/bin/bash

# 确保GOPATH变量有设置
if test -z "${GOPATH}"; then
  echo "Please set the environment variable GOPATH before running make"
  exit 1
fi
`,
	})

	t.files = append(t.files, &templateFile{
		name: "scripts/templates/Dockerfile",
		body: `
FROM {{IMAGE_FROM}}

WORKDIR /opt

COPY build/service /opt/service
COPY config/app-mini.yaml /opt/config/app.yaml

EXPOSE 10080/tcp
EXPOSE 10081/tcp

ENTRYPOINT [ "/opt/service" ]
CMD [ "--config", "/opt/config/app.yaml" ]
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/version.sh",
		parse: true,
		body: `
#!/bin/bash

source scripts/env

if test -z $1; then
  echo "Usage:"
  echo "\t ./scripts/version.sh prefix"
  echo "\t ./scripts/version.sh release"
  echo "\t ./scripts/version.sh update"
  exit 0;
fi

function prefix() {
  TEMP=$(grep "version: \".*\"" api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml)
  PREFIX_VERSION=$(echo -n $TEMP | awk -F"\"" '{ print $2 }')
  echo $PREFIX_VERSION
}

function release() {
  TEMP=$(cat VERSION)
  RELEASE_VERSION=$TEMP

  if test -z $RELEASE_VERSION; then
    RELEASE_VERSION=$(git describe --tags --dirty --always 2>/dev/null)
  fi

  echo $RELEASE_VERSION
}

function update() {
  GOHOSTOS=$(go env GOHOSTOS)

  PREFIX_VERSION=$(prefix)
  RELEASE_VERSION=$(release)

  if test $PREFIX_VERSION == $RELEASE_VERSION; then
    return
  fi

  if test ${GOHOSTOS} = "darwin"; then
    sed -i "" "s#version: \"${PREFIX_VERSION}\"#version: \"${RELEASE_VERSION}\"#g" api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml
  else
    # fix run in container
    # sed: couldn't open temporary file sed1DDoX9: Permission denied
    #sed -i "s#version: \"${PREFIX_VERSION}\"#version: \"${RELEASE_VERSION}\"#g" api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml
    cp api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml /tmp/microservice.openapiv2.yaml
    sed -i "s#version: \"${PREFIX_VERSION}\"#version: \"${RELEASE_VERSION}\"#g" /tmp/microservice.openapiv2.yaml
    mv /tmp/microservice.openapiv2.yaml api/${PRODUCT_CODE}/${SHORT_NAME}/${API_VERSION}/microservice.openapiv2.yaml > /dev/null 2>&1
  fi
}

$1
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/manifests.sh",
		parse: true,
		body: `
#!/bin/bash

source scripts/env

if test -z $1; then
  echo "Usage:"
  echo "\t ./scripts/manifests.sh dev"
fi

GOHOSTOS=$(go env GOHOSTOS)
DEPLOY_ENV=$1

# 生成的容器镜像地址
IMAGE_ADDR=${IMAGE_HOST}/${NAMESPACE}/${SHORTNAME}:${IMAGE_VERSION}

function clean() {
  rm -rf deploy/systemd/
  rm -rf deploy/supervisor/
  rm -rf deploy/kubernetes/${DEPLOY_ENV}
}

function systemd() {
  mkdir -p deploy/systemd/
  cp -rf scripts/templates/systemd/* deploy/systemd/
}

function supervisor() {
  mkdir -p deploy/supervisor/
  cp -rf scripts/templates/supervisor/* deploy/supervisor/
}

function kubernetes() {
  mkdir -p deploy/kubernetes/${DEPLOY_ENV}/
  mkdir -p deploy/kubernetes/${DEPLOY_ENV}/config/configmap/
  cp -rf scripts/templates/kubernetes/* deploy/kubernetes/${DEPLOY_ENV}/

  if test -f config/app-${DEPLOY_ENV}-${BUILD_ENV}.yaml; then
    cp -a config/app-${DEPLOY_ENV}-${BUILD_ENV}.yaml deploy/kubernetes/${DEPLOY_ENV}/config/configmap/app.yaml
  fi

  if test ${GOHOSTOS} = "darwin"; then
    sed -i "" "s#DEPLOY_ENV#${DEPLOY_ENV}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "" "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "" "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/workloads/deployment.yaml
    sed -i "" "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/service/ingresses.yaml
    sed -i "" "s#DEPLOY_ENV#${DEPLOY_ENV}#g" deploy/kubernetes/${DEPLOY_ENV}/service/ingresses.yaml
    sed -i "" "s#IMAGE_NAME#${IMAGE_NAME}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "" "s#IMAGE_NAME#${IMAGE_NAME}#g" deploy/kubernetes/${DEPLOY_ENV}/workloads/deployment.yaml
    sed -i "" "s#IMAGE_VERSION#${IMAGE_VERSION}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
  else
    sed -i "s#DEPLOY_ENV#${DEPLOY_ENV}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/workloads/deployment.yaml
    sed -i "s#NAMESPACE#${NAMESPACE}#g" deploy/kubernetes/${DEPLOY_ENV}/service/ingresses.yaml
    sed -i "s#DEPLOY_ENV#${DEPLOY_ENV}#g" deploy/kubernetes/${DEPLOY_ENV}/service/ingresses.yaml
    sed -i "s#IMAGE_NAME#${IMAGE_NAME}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
    sed -i "s#IMAGE_NAME#${IMAGE_NAME}#g" deploy/kubernetes/${DEPLOY_ENV}/workloads/deployment.yaml
    sed -i "s#IMAGE_VERSION#${IMAGE_VERSION}#g" deploy/kubernetes/${DEPLOY_ENV}/kustomization.yaml
  fi
}

clean
systemd
supervisor
kubernetes
`,
	})

	t.files = append(t.files, &templateFile{
		name:  fmt.Sprintf("scripts/templates/systemd/%v-%v-%v.service", t.config.Global.ProductCode, t.config.Global.ShortName, t.config.Template.Service.APIVersion),
		parse: true,
		body: `
[Unit]
After=network-online.target
Documentation=http://(app.yaml:services.http_address)/openapi-spec/
Description=The {{ .Global.ShortName }}.{{ .Template.Service.APIVersion }}.{{ .Global.ProductCode }} microservice. For more API detailed, please refer to the docs

[Service]
Type=simple
User=nobody
Restart=always
RestartSec=15s
TimeoutSec=60s
LimitNOFILE=65535
KillMode=control-group
MemoryLimit=2048M
ExecStart=/usr/local/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}/service --config /usr/local/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}/config/app.yaml

[Install]
Alias={{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}.service
WantedBy=multi-user.target
`,
	})

	t.files = append(t.files, &templateFile{
		name:  fmt.Sprintf("scripts/templates/supervisor/%v-%v-%v.conf", t.config.Global.ProductCode, t.config.Global.ShortName, t.config.Template.Service.APIVersion),
		parse: true,
		body: `
[program:{{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}]
command=/usr/local/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}/service --config /usr/local/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}/config/app.yaml
directory=/usr/local/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}/
autostart=true
autorestart=true
startsecs=10
startretries=3
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/templates/kubernetes/kustomization.yaml",
		parse: true,
		body: `
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: biz-DEPLOY_ENV-NAMESPACE

commonLabels:
  {{ .Global.APIEndpoint }}/appname: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
  {{ .Global.APIEndpoint }}/pm2-uuid: 3264e3fe-2bce-4835-8588-99651a8ddd3b

commonAnnotations:
  {{ .Global.APIEndpoint }}/pm2-uuid: 3264e3fe-2bce-4835-8588-99651a8ddd3b

configMapGenerator:
- name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
  files:
  - app.yaml=config/configmap/app.yaml
  options:
    disableNameSuffixHash: true

replicas:
- name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
  count: 1

resources:
- service/ingresses.yaml
- service/services.yaml
- workloads/deployment.yaml

images:
- name: IMAGE_NAME
  newTag: IMAGE_VERSION
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/templates/kubernetes/service/ingresses.yaml",
		parse: true,
		body: `
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  #annotations:
  #  nginx.ingress.kubernetes.io/proxy-body-size: 10m
  name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
spec:
  ingressClassName: nginx
  rules:
  - host: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}.biz-DEPLOY_ENV-NAMESPACE.{{ .Global.APIEndpoint }}
    http:
      paths:
      - path: /
        backend:
          service:
            name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
            port:
              number: 10080
        pathType: Prefix
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/templates/kubernetes/service/services.yaml",
		parse: true,
		body: `
---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
spec:
  ports:
  - name: http
    port: 10080
    protocol: TCP
    targetPort: 10080
  - name: grpc
    port: 10081
    protocol: TCP
    targetPort: 10081
  sessionAffinity: None
  type: ClusterIP
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "scripts/templates/kubernetes/workloads/deployment.yaml",
		parse: true,
		body: `
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
spec:
  revisionHistoryLimit: 3
  strategy:
    rollingUpdate:
      maxSurge: 100%
      maxUnavailable: 0%
    type: RollingUpdate
  template:
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                {{ .Global.APIEndpoint }}/appname: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
            topologyKey: kubernetes.io/hostname
      containers:
      - args:
        - /opt/service
        - --config
        - /opt/config/app.yaml
        env:
        - name: GRPC_KIT_PUHLIC_IP
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: status.podIP
        image: IMAGE_NAME:latest
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 5
          initialDelaySeconds: 30
          periodSeconds: 30
          successThreshold: 1
          tcpSocket:
            port: 10081
          timeoutSeconds: 5
        name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz?service={{ .Global.ShortName }}.{{ .Template.Service.APIVersion }}.{{ .Global.ProductCode }}
            port: 10080
            scheme: HTTP
          initialDelaySeconds: 15
          periodSeconds: 15
          successThreshold: 1
          timeoutSeconds: 5
        resources:
          limits:
            cpu: "4000m"
            memory: 4048Mi
          requests:
            cpu: 100m
            memory: 100Mi
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /opt/config
          name: config-volume
        - mountPath: /opt/logs/applog
          name: applog-volume
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - NET_ADMIN
            - SYS_ADMIN
            - NET_RAW
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext:
        runAsGroup: 65534
        runAsUser: 65534
        runAsNonRoot: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: config-volume
        configMap:
          defaultMode: 420
          name: {{ .Global.ProductCode }}-{{ .Global.ShortName }}-{{ .Template.Service.APIVersion }}
      - name: applog-volume
        emptyDir: {}
`,
	})

	t.files = append(t.files, &templateFile{
		name: "scripts/binaries.sh",
		body: `
#!/bin/bash

source scripts/env

if test -z $1; then
  echo "Usage:"
  echo "\t ./scripts/binaries.sh protoc-gen-go"
  exit 0;
fi

# https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-linux-x86_64.zip
# https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-linux-aarch_64.zip
# https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-osx-aarch_64.zip
# https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-osx-x86_64.zip
function protoc() {
  GOHOSTOS=$(go env GOHOSTOS)
  GOARCH=$(go env GOARCH)
  GOPATH=$(go env GOPATH)

  TARGET_OS=$GOHOSTOS
  TARGET_ARCH=$GOARCH

  if test "$GOHOSTOS" == "darwin"; then
    TARGET_OS="osx"
  fi

  if test "$GOARCH" == "arm64"; then
    TARGET_ARCH="aarch_64"
  elif test "$GOARCH" == "amd64"; then
    TARGET_ARCH="x86_64"
  fi

  echo "https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-"$TARGET_OS"-"$TARGET_ARCH".zip"

  cd /tmp
  curl -L -O "https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-"$TARGET_OS"-"$TARGET_ARCH".zip"

  unzip protoc-21.12-"$TARGET_OS"-"$TARGET_ARCH".zip
  mv bin/protoc "$GOPATH/bin/"
  mv include/google /usr/local/include/

  rm -f protoc-21.12-"$TARGET_OS"-"$TARGET_ARCH".zip
  rm -f readme.txt
  rmdir bin/
  rmdir include/
}

function protoc-gen-go-grpc() {
  go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
}

function protoc-gen-go() {
  go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
}

function protoc-gen-grpc-gateway() {
  go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@v2.15.2
}

function protoc-gen-openapiv2() {
  go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@v2.15.2
}

FILE=$(which $1)
if test -f "$FILE"; then
  echo "the binary already exists at: "$FILE""
else
  $1
  echo "download complete, this will place binaries in your \$GOBIN, make sure that your \$GOBIN is in your \$PATH."
fi
`,
	})

}
