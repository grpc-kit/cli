// Copyright © 2020 The gRPC Kit Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

func (t *templateService) fileDirectoryCmd() {
	t.files = append(t.files, &templateFile{
		name:  "cmd/server/main.go",
		parse: true,
		body: `
// Code generated by "grpc-kit-cli/{{ .Global.ReleaseVersion }}". DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"os"

	"github.com/grpc-kit/pkg/cfg"
	"github.com/grpc-kit/pkg/signal"
	"github.com/grpc-kit/pkg/vars"
	flag "github.com/spf13/pflag"
	"github.com/spf13/viper"

	"{{ .Global.Repository }}/handler"
)

var (
	flagCfgFile *string
	flagVersion *bool
)

func init() {
	flagCfgFile = flag.StringP("config", "c", "./config/app.yaml", "config file")
	flagVersion = flag.BoolP("version", "v", false, "print version and exit")
	flag.Parse()

	if *flagVersion {
		fmt.Println(vars.GetVersion())
		os.Exit(0)
	}
}

func main() {
	viper.SetConfigFile(*flagCfgFile)

	if err := viper.ReadInConfig(); err == nil {
		fmt.Printf("Using config file: %v\n", *flagCfgFile)
	} else {
		fmt.Printf("Load config file: %v, err: %v\n", *flagCfgFile, err)
		os.Exit(1)
	}

	ctx := context.Background()

	m, err := startServer(ctx)
	if err != nil {
		fmt.Printf("Start server err: %v\n", err)
		os.Exit(1)
	}

	signal.WaitQuit()

	if err := m.Shutdown(ctx); err != nil {
		fmt.Printf("Shutdown server err: %v\n", err)
		os.Exit(1)
	}
}

func startServer(ctx context.Context) (*handler.Microservice, error) {
	lc, err := cfg.New(viper.GetViper())
	if err != nil {
		return nil, err
	}

	m, err := handler.NewMicroservice(lc)
	if err != nil {
		return nil, err
	}

	if err := m.Register(ctx); err != nil {
		return nil, err
	}

	return m, nil
}
`,
	})

	t.files = append(t.files, &templateFile{
		name:  "cmd/client/health.go",
		parse: true,
		body: `
package main

import (
	"context"
	"fmt"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	_ "google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"

	statusv1 "github.com/grpc-kit/pkg/api/known/status/v1"
	pb "{{ .Global.Repository }}/api/{{ .Global.ProductCode }}/{{ .Global.ShortName }}/{{ .Template.Service.APIVersion }}"
)

var serviceConfig = "{\"loadBalancingPolicy\": \"round_robin\",\"healthCheckConfig\": {\"serviceName\": \"\"}}"

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
	defer cancel()

	var err error
	cc, err := grpcConn(ctx)
	if err != nil {
		fmt.Println(err)
		return
	}

	if err = grpcHealth(ctx, cc); err != nil {
		fmt.Println(err)
		return
	} else {
		fmt.Println("grpc_health_v1 check ok")
	}

	if err = grpcHealthPrivate(ctx, cc); err != nil {
		fmt.Println(err)
		return
	} else {
		fmt.Println("grpc health private check ok")
	}
}

func grpcConn(ctx context.Context) (*grpc.ClientConn, error) {
	// TODO; 仅用于测试，配置为该服务对外的地址
	cc, err := grpc.DialContext(ctx, "127.0.0.1:10081",
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithDefaultServiceConfig(serviceConfig))
	if err != nil {
		return nil, err
	}

	return cc, err
}

// grpcHealth 利用标准 grpc 健康检测
func grpcHealth(ctx context.Context, cc *grpc.ClientConn) error {
	c := grpc_health_v1.NewHealthClient(cc)
	resp, err := c.Check(ctx, &grpc_health_v1.HealthCheckRequest{})
	if err != nil {
		return err
	}

	if resp.GetStatus().String() != "SERVING" {
		return fmt.Errorf("grpc_health_v1 check fail, val: %v", resp.GetStatus().String())
	}

	return err
}

// grpcHealthPrivate 服务内自定义健康检测
func grpcHealthPrivate(ctx context.Context, cc *grpc.ClientConn) error {
	c := pb.New{{ .Global.ServiceTitle }}Client(cc)
	resp, err := c.HealthCheck(ctx, &statusv1.HealthCheckRequest{Service: "{{ .Global.ShortName }}.{{ .Template.Service.APIVersion }}.{{ .Global.ProductCode }}"})
	if err != nil {
		return err
	}

	if resp.GetStatus().String() != "SERVING" {
		return fmt.Errorf("grpc health private check fail")
	}

	return nil
}
`,
	})
}
